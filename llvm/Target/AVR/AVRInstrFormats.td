//===-- AVRInstrInfo.td - AVR Instruction Formats ----------*- tablegen -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// AVR Instruction Format Definitions.
//
//===----------------------------------------------------------------------===//

//:TODO: describe register and operands page 1 from inset.pdf

// AVR generic instruction
class AVRInst<dag outs, dag ins, string asmstr, list<dag> pattern> : Instruction
{
  let Namespace = "AVR";

  dag OutOperandList = outs;
  dag InOperandList = ins;
  let AsmString = asmstr;
  let Pattern = pattern;
}

//:TODO: hack to define 16 and 32 bit instructions, find a better way??!
class AVRInst16<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst<outs, ins, asmstr, pattern>
{
  field bits<16> Inst;
}

class AVRInst32<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst<outs, ins, asmstr, pattern>
{
  field bits<32> Inst;
}

// Pseudo instructions
class Pseudo<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  let Pattern = pattern;
  let Inst{15-0} = 0;
}

//:TODO: set is isAsCheapAsAMove per format instead of per instruction??!
// :TODO:REMAT LDI!?

//===----------------------------------------------------------------------===//
// Register / register instruction: <|opcode|ffrd|dddd|rrrr|>
// opcode = 4 bits.
// f = secondary opcode = 2 bits
// d = destination = 5 bits
// r = source = 5 bits
// (Accepts all registers)
//===----------------------------------------------------------------------===//
class FRdRr<bits<4> opcode, bits<2> f, dag outs, dag ins, string asmstr,
            list<dag> pattern> : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;
  bits<5> r;

  let Inst{15-12} = opcode;
  let Inst{11-10} = f;
  let Inst{9} = r{4};
  let Inst{8-4} = d;
  let Inst{3-0} = r{3-0};
}

//===----------------------------------------------------------------------===//
// Register / immediate8 instruction: <|opcode|KKKK|dddd|KKKK|>
// opcode = 4 bits.
// K = constant data = 8 bits
// d = destination = 4 bits
// (Only accepts r16-r31)
//===----------------------------------------------------------------------===//
class FRdK<bits<4> opcode, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;              // accept 5 bits but only encode the lower 4
  bits<8> K;

  let Inst{15-12} = opcode;
  let Inst{11-8} = K{7-4};
  let Inst{7-4} = d{3-0};
  let Inst{3-0} = K{3-0};
}

//===----------------------------------------------------------------------===//
// Register instruction: <|opcode|fffd|dddd|ffff|>
// opcode = 4 bits.
// f = secondary opcode = 7 bits
// d = destination = 5 bits
// (Accepts all registers)
//===----------------------------------------------------------------------===//
class FRd<bits<4> opcode, bits<7> f, dag outs, dag ins, string asmstr,
          list<dag> pattern> : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;

  let Inst{15-12} = opcode;
  let Inst{11-9} = f{6-4};
  let Inst{8-4} = d;
  let Inst{3-0} = f{3-0};
}

//===----------------------------------------------------------------------===//
// MOVWRdRr special encoding: <|0000|0001|dddd|rrrr|>
// d = destination = 4 bits
// r = source = 4 bits
// (Only accepts even registers)
//===----------------------------------------------------------------------===//
class FMOVWRdRr<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;
  bits<5> r;

  let Inst{15-8} = 0b00000001;
  let Inst{7-4} = d{3-0};
  let Inst{3-0} = r{3-0};
}

//===----------------------------------------------------------------------===//
// MULrr special encoding: <|1001|11rd|dddd|rrrr|>
// d = multiplicand = 5 bits
// r = multiplier = 5 bits
// (Accepts all registers)
//===----------------------------------------------------------------------===//
class Mu1RdRr<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;
  bits<5> r;

  let Inst{15-10} = 0b100111;
  let Inst{9} = r{4};
  let Inst{8-4} = d;
  let Inst{3-0} = r{3-0};
}

//===----------------------------------------------------------------------===//
// MULSrr special encoding: <|0000|0010|dddd|rrrr|>
// d = multiplicand = 4 bits
// r = multiplier = 4 bits
// (Only accepts r16-r31)
//===----------------------------------------------------------------------===//
class Mu2RdRr<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;              // accept 5 bits but only encode the lower 4
  bits<5> r;              // accept 5 bits but only encode the lower 4

  let Inst{15-8} = 0b00000010;
  let Inst{7-4} = d{3-0};
  let Inst{3-0} = r{3-0};
}

//===----------------------------------------------------------------------===//
// Rest of multiplication instructions: <|0000|0011|fddd|frrr|>
// f = secondary opcode = 2 bits
// d = multiplicand = 3 bits
// r = multiplier = 3 bits
// (Only accepts r16-r23)
//===----------------------------------------------------------------------===//
class Mu3RdRr<bits<2> f, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;              // accept 5 bits but only encode the lower 3
  bits<5> r;              // accept 5 bits but only encode the lower 3

  let Inst{15-8} = 0b00000011;
  let Inst{7} = f{1};
  let Inst{6-4} = d{2-0};
  let Inst{3} = f{0};
  let Inst{2-0} = r{2-0};
}

//===----------------------------------------------------------------------===//
// Arithmetic word instructions (ADIW / SBIW): <|1001|011f|KKdd|KKKK|>
// f = secondary opcode = 1 bit
// K = constant data = 6 bits
// d = destination = 4 bits
// (Only accepts r25:24 r27:26 r29:28 r31:30)
//===----------------------------------------------------------------------===//
class FWRdK<bit f, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;              // accept 5 bits but only encode bits 1 and 2
  bits<6> K;

  let Inst{15-9} = 0b1001011;
  let Inst{8} = f;
  let Inst{7-6} = K{5-4};
  let Inst{5-4} = d{2-1};
  let Inst{3-0} = K{3-0};
}

//===----------------------------------------------------------------------===//
// In I/O instruction: <|1011|0AAd|dddd|AAAA|>
// A = I/O location address = 6 bits
// d = destination = 5 bits
// (Accepts all registers)
//===----------------------------------------------------------------------===//
class FIORdA<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<5> d;
  bits<6> A;

  let Inst{15-11} = 0b10110;
  let Inst{10-9} = A{5-4};
  let Inst{8-4} = d;
  let Inst{3-0} = A{3-0};
}

//===----------------------------------------------------------------------===//
// Out I/O instruction: <|1011|1AAr|rrrr|AAAA|>
// A = I/O location address = 6 bits
// d = destination = 5 bits
// (Accepts all registers)
//===----------------------------------------------------------------------===//
class FIOARr<dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<6> A;
  bits<5> r;

  let Inst{15-11} = 0b10111;
  let Inst{10-9} = A{5-4};
  let Inst{8-4} = r;
  let Inst{3-0} = A{3-0};
}

//===----------------------------------------------------------------------===//
// Conditional Branching instructions: <|1111|0fkk|kkkk|ksss|>
// f = secondary opcode = 1 bit
// k = constant address = 7 bits
// s = bit in status register = 3 bits
//===----------------------------------------------------------------------===//
class FBRsk<bit f, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<3> s;
  bits<7> k;

  let Inst{15-11} = 0b11110;
  let Inst{10} = f;
  let Inst{9-3} = k;
  let Inst{2-0} = s;
}

//===----------------------------------------------------------------------===//
// Branching instructions: <|opcode|>
//===----------------------------------------------------------------------===//
class FBR<bits<16> opcode, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  let Inst = opcode;
}

//===----------------------------------------------------------------------===//
// Branching instructions with immediate12: <|110f|kkkk|kkkk|kkkk|>
// f = secondary opcode = 1 bit
// k = constant address = 12 bits
//===----------------------------------------------------------------------===//
class FBRk<bit f, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst16<outs, ins, asmstr, pattern>
{
  bits<12> k;

  let Inst{15-13} = 0b110;
  let Inst{12} = f;
  let Inst{11-0} = k;
}

//===----------------------------------------------------------------------===//
// 32 bits branching instructions: <|1001|010k|kkkk|fffk|kkkk|kkkk|kkkk|kkkk|>
// f = secondary opcode = 3 bits
// k = constant address = 22 bits
//===----------------------------------------------------------------------===//
class F32BRk<bits<3> f, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst32<outs, ins, asmstr, pattern>
{
  bits<22> k;

  let Inst{31-25} = 0b1001010;
  let Inst{24-20} = k{21-17};
  let Inst{19-17} = f;
  let Inst{16-0} = k{16-0};
}

//===----------------------------------------------------------------------===//
// 32 bits direct mem instructions: <|1001|00fd|dddd|0000|kkkk|kkkk|kkkk|kkkk|>
// f = secondary opcode = 1 bit
// d = destination = 5 bits
// k = constant address = 16 bits
// (Accepts all registers)
//===----------------------------------------------------------------------===//
class F32DM<bit f, dag outs, dag ins, string asmstr, list<dag> pattern>
  : AVRInst32<outs, ins, asmstr, pattern>
{
  bits<16> k;
  bits<5> d;

  let Inst{31-26} = 0b100100;
  let Inst{25} = f;
  let Inst{24-20} = d;
  let Inst{19-16} = 0b0000;
  let Inst{15-0} = k{15-0};
}
